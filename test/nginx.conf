worker_processes 1; # Ok for testing purposes
error_log logs/error.log debug; # Wanna see the debug messages we put in the code
events { worker_connections 1024; } # Standard, no need to overthink

http {
    # Cache storage area settings
    # levels -> Dir hierarchy to prevent stacking all files into one dir
    # keys_zone -> define shared memory zone for keys and metadata
    # max_size -> what can the cache hold before erasing old entries
    # inactive -> after what time of inactivity to erase data
    proxy_cache_path /tmp/nginx_cache levels=1:2 keys_zone=my_cache:10m max_size=100m inactive=60m;

     log_format cache_debug '$remote_addr [$time_local] "$request" '
                                       '$status'
                                       '"$http_user_agent"'
                                       'cache_status=$upstream_cache_status';

    server {
        # Proxy server location supporting ssl
        listen 8443 ssl;
        server_name localhost;

        access_log logs/access.log cache_debug;

        # SSL conf, using self signed certs for simplification
        ssl_certificate /etc/nginx/ssl/nginx-selfsigned.crt;
        ssl_certificate_key /etc/nginx/ssl/nginx-selfsigned.key;

        location / {
            # Backend conf, use secure comm
            proxy_pass https://httpbin.org/get;

            # Cache conf
            proxy_cache my_cache; # The one from proxy_cache_path
            proxy_cache_key "$scheme$request_method$host$request_uri"; # What input goes into the key calculation process
            proxy_cache_valid 200 1m; # Maps response code to content freshness time (200 1m => 200 OK responses are fresh for 1 minute)
        }
    }
}
